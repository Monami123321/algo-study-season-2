class Solution {
    public int[] solution(long[] numbers) {
        
        
        
        int[] answer = new int[numbers.length];
        
        
        for(int i=0; i<numbers.length;i++){
            String biStr = Long.toBinaryString(numbers[i]);
            int idx = 1;
            
            // 아니 제발ㅠ
            // 포화이진트리
            int h = 1;
            int cnt = 1;
            while( cnt < biStr.length()){
                cnt = 1+ cnt*2;
                h++;
            }
            
            // 중간이 빌 수도 있지만, 그냥 좌측으로 밀어도 상관 없지 않나? 
            // 아, 아닌가,,,,
            // 가장 끝의 좌측부터 하나씩 채우고 중간까지 채워야 되는데
            // 채우는 중간의 위치를 어떻게 계산하나?
        
            for(int i=0 ;i<h;i++){
                biStr = "0"+biStr;
            }
            
            int lengthStr = biStr.length();
            
            while(lengthStr > 0 ){
                // 이렇게 하는 것보다 dfs로 양쪽 완탐 돌리는게 맞을 듯
                
                // 전체 길이에서 중간값 1 빼고 /2하기
                // 중간 위치의 노드가 0이 아니라면 계속 
                // 0 이라면 불가능이므로 바로 0 반환
                
            }
            
            
            
            
            //answer[i] = ?
        }
        
        return answer;
    }
}